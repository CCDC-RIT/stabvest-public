<!--
incidents_dashboard.html
Incidents Dashboard UI for Stabvest Agent incidents

How to use:
1. Place this file on the same origin as your Flask backend (recommended) so fetch() to /list_incidents and /update_incident_tag works without CORS issues.
2. If you must serve it separately, enable CORS on your Flask server or proxy requests.
3. The page will try to POST {} to /list_incidents to fetch incidents.
   To update tags it will POST { incident_id, tag } to /update_incident_tag.
4. The server responses expected:
   - /list_incidents returns a JSON mapping of incident_id -> incident object,
     e.g. {"1": { "agent_id": 5, "message": "Cannot read firewall powershell", "newStatus": true, "oldStatus": true, "tag": "Closed", "timestamp": 1764542841.9764404 }, ... }
   - /update_incident_tag returns 200 OK with body "ok" or appropriate error codes.

Design notes & assumptions:
- Incident "type" is inferred client-side from message and statuses:
  * If message contains "Cannot read" -> "No Logs"
  * If newStatus !== oldStatus -> "Successful remediation"
  * If newStatus === oldStatus -> "Failed remediation"
  These mappings are intentionally local so you can change heuristics without touching the server.
- Tag values accepted by server: "New", "Active", "Closed".
- The UI supports search, type filters, tag filters, sorting, and optimistic updates.
- The code is modular: `api`, `ui`, and `utils` sections so future functions can be dropped in easily.

Security & production notes:
- /update_incident_tag may require operator/admin privileges (per server). The UI will still attempt the POST and surface errors.
- If you need CSRF/auth tokens, extend `api.getHeaders()` to include them.
-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Incidents Dashboard</title>

<!-- Minimal, modern styling (no external frameworks so this is drop-in) -->
<style>
  :root{
    --bg:#272b33; /*--bg:#0f1724;*/
    --card:#0b1320;
    --muted:#9aa6b2;
    --accent:#60a5fa;
    --success:#16a34a;
    --danger:#ef4444;
    --warning:#f59e0b;
    /*--color-firewall:    #3b9102;
    --color-interface:  #01410b;
    --color-service-generic:   #b87700;
    --color-service-custom: #5e4902;
    --color-agent-alert: #04459b;
    --color-server:  #9306a0;
    --color-ir:  #a81106;
    --color-inject:  #430477;
    --color-uptime:  #5a0b05;
    --color-unknown:   #5e5e5e;
    --color-firewall:    #FF968A;
    --color-interface:  #FFAEA5;
    --color-service-generic:   #FFC5BF;
    --color-service-custom: #FFD8BE;
    --color-agent-alert: #FFC8A2;
    --color-server:  #ECD5E3;
    --color-ir:  #B6CFB6;
    --color-inject:  #8FCACA;
    --color-uptime:  #CCE2CB;*/
    --color-firewall:    #641f1a;
    --color-interface:  #91251e;
    --color-service-generic:   #8C573A;
    --color-service-custom: #a37526;
    --color-agent-alert: #404C24;
    --color-server:  #6d39cf;
    --color-ir:  #4e08aa;
    --color-inject:  #036995;
    --color-uptime:  #380a8e;
    --color-file:   #b11226;
    --color-unknown:   #5e5e5e;
    --glass: rgba(255,255,255,0.03);
    --radius:12px;
    --max-width:1200px;
    --card-gap:18px;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color-scheme: dark;
  }

  .color-firewall        { color: var(--color-firewall); }
  .color-interface       { color: var(--color-interface); }
  .color-service-generic { color: var(--color-service-generic); }
  .color-service-custom  { color: var(--color-service-custom); }
  .color-agent-alert     { color: var(--color-agent-alert); }
  .color-ir              { color: var(--color-ir); }
  .color-inject          { color: var(--color-inject); }
  .color-uptime          { color: var(--color-uptime); }
  .color-server          { color: var(--color-server); }
  .color-file          { color: var(--color-file); }
  .color-unknown         { color: var(--color-unknown); }
  .sla-red        { color: #8b0000; }   /* dark red */
  .sla-green      { color: #00ff66; }
  .sla-yellow     { color: #ffd700; }
  .sla-orange     { color: #ffa500; }
  .sla-blood      { color: #ff4500; }   /* blood orange */
  .sla-none       { color: #cccccc; }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#061026 0%, #071426 100%);color:#dbe7f0;}
  .container{
    /*max-width:var(--max-width);*/
    width: 100%;
    max-width: 100vw;   /* full viewport width */
    margin:14px auto;
    padding:20px;
    box-sizing: border-box; /* ensures padding doesn’t overflow */
  }
  header{display:flex;gap:16px;align-items:center;margin-bottom:18px;}
  h1{margin:0;font-size:22px;letter-spacing:0.2px;}
  .sub{color:var(--muted);font-size:13px;margin-top:4px;}
  /* controls */
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:14px 0 20px 0;}
  .control, input[type="search"], select, button {
    background:var(--card);
    border:1px solid rgba(255,255,255,0.03);
    padding:8px 12px;
    border-radius:10px;
    color:inherit;
    outline:none;
    font-size:13px;
  }
  input[type="search"]{min-width:260px}
  .chip{padding:6px 10px;border-radius:999px;font-weight:600;background:var(--glass);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
  .chip.active{box-shadow:0 6px 18px rgba(0,0,0,0.6);transform:translateY(-1px);}
  .grid{
    display:grid;
    grid-template-columns: repeat(auto-fit, 385px);
    justify-content: center;   /* center the grid in the container */
    /*grid-template-columns:repeat(auto-fill,minmax(500px,1fr));*/
    /*grid-template-columns: repeat(5, 1fr);*/
    gap:var(--card-gap);
  }
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:14px;border-radius:var(--radius);box-shadow:0 6px 20px rgba(2,6,23,0.75);border:1px solid rgba(255,255,255,0.02);
    display:flex;flex-direction:column;gap:8px;
  }
  .meta{display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--muted)}
  .message{font-weight:600;font-size:15px}
  .small{font-size:13px;color:var(--muted)}
  .badge{display:inline-flex;gap:8px;align-items:center;padding:6px 8px;border-radius:999px;font-weight:700;font-size:12px}
  .badge.tag-New{background:rgba(96,165,250,0.14);color:var(--accent);border:1px solid rgba(96,165,250,0.08)}
  .badge.tag-Active{background:rgba(245,158,11,0.12);color:var(--warning);border:1px solid rgba(245,158,11,0.08)}
  .badge.tag-Closed{background:rgba(16,163,127,0.08);color:var(--success);border:1px solid rgba(16,163,127,0.06)}
  .type-NoLogs{color:var(--warning);font-weight:700}
  .type-Failed{color:var(--danger);font-weight:700}
  .type-Success{color:var(--success);font-weight:700}
  .actions{display:flex;gap:8px;margin-top:6px}
  .btn{padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:700}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.03)}
  .btn.claim{background:linear-gradient(90deg,#f97316,#ef4444);color:white}
  .btn.resolve{background:linear-gradient(90deg,#10b981,#059669);color:white}
  .btn.reopen{background:linear-gradient(90deg,#60a5fa,#3b82f6);color:white;}
  .btn.details{background:linear-gradient(90deg,#00e2d7,#02c5abce);color:white;}
  .btn.sla{background:linear-gradient(90deg,#a700f5,#a009dbce);color:white;}
  .footer{margin-top:18px;color:var(--muted);font-size:13px}
  .topbar-stats{display:flex;gap:12px;align-items:center}
  .stat{background:var(--card);padding:8px;border-radius:10px;font-size:13px;color:var(--muted)}
  .toast{position:fixed;right:20px;bottom:20px;background:#061426;padding:12px 16px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)}
  .muted-note{color:var(--muted);font-size:13px}
  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.65);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
  }

  .modal-content {
    background: #1e1e1e;
    padding: 1rem;
    border-radius: 10px;
    width: 350px;
    box-shadow: 0 0 15px rgba(0,0,0,0.7);
  }

  .modal-content h2 {
    margin-top: 0;
    border-bottom: 1px solid #333;
    padding-bottom: 0.5rem;
  }

  .modal-content input,
  .modal-content textarea {
    width: 100%;
    margin: 0.25rem 0 0.75rem 0;
    background: #2a2a2a;
    color: #e0e0e0;
    border: none;
    border-radius: 6px;
    padding: 0.5rem;
  }

  .modal-content textarea {
    resize: vertical;
    min-height: 70px;
  }

  .modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
  }

    
  .site-footer {
      background-color: #042033; /* light gray */
      text-align: center;
      padding: 15px 0;
      font-size: 0.9rem;
      color: #555;
      /*border-top: 1px solid #e0e0e0;*/
  }

  .site-footer a {
      color: #007bff; /* blue link */
      text-decoration: none;
      font-weight: 500;
  }

  .site-footer a:hover {
      text-decoration: underline;
  }

  .header-container {
      display: flex;
      align-items: center;      /* vertically align image and text */
      gap: 10px;                /* space between image and text */
      flex-wrap: wrap;          /* wrap text to next line if needed */
  }

  .header-container h1 {
      margin: 0;
  }

  .header-icon {
      width: 40px;              /* adjust size as needed */
      height: 40px;
  }

  /* responsive tweaks */
  @media (max-width:700px){ .controls{flex-direction:column;align-items:stretch} header{flex-direction:column;align-items:flex-start} .topbar-stats{flex-wrap:wrap} }
</style>
</head>
<body>
  <div class="container" id="app">
    <header>
      <div class="header-container">
        <img src="../static/favicon.ico" alt="RIT Tiger" class="header-icon">
        <h1>Incidents Dashboard</h1>
        <a href="/" style="padding-left: 20px;">Back to Home</a>
        <div style="padding-left: 20px;">
          <div class="sub">Click <strong>Claim</strong> to tag an incident as <em>Active</em>, <strong>Resolve</strong> to tag as <em>Closed</em>, or <strong>Reopen</strong> to mark as <em>New</em>. You must have <code>Analyst</code> permissions to do this.</div>
          <div class="sub">Issue Colors: <span class="color-firewall">Firewall</strong>, <span class="color-interface">Interface</span>, <span class="color-service-generic">Service Generic</span>, <span class="color-service-custom">Service Custom</span>, <span class="color-file">File</span>, <span class="color-agent-alert">Agent Alert</span>, <span class="color-ir">IR</span>, <span class="color-inject">Inject</span>, <span class="color-uptime">Uptime</span>, <span class="color-server">Server</span>, <span class="color-unknown">Other</span>.</div>
          <div class="sub">Tip: use "<strong>incident</strong> <code>(number)</code>" as a search term to limit results to only incidents.</div>
        </div>
      </div>
      <div style="flex:1"></div>
      <div class="topbar-stats" aria-hidden>
        <div class="stat" id="stat-total">Total: —</div>
        <div class="stat" id="stat-active">Active: —</div>
        <div class="stat" id="stat-new">New: —</div>
        <div class="stat" id="stat-closed">Closed: —</div>
      </div>
    </header>

    <!-- Controls: search, filters, sort, refresh -->
    <div class="controls" role="toolbar" aria-label="dashboard controls">
      <input type="search" id="search" placeholder="Search msg, agent, assignee, inc #..." aria-label="Search incidents">

      <select id="tagFilter" aria-label="Filter by tag">
        <option value="alive">New or Active</option>
        <option value="New">New</option>
        <option value="Active">Active</option>
        <option value="Closed">Closed</option>
        <option value="any">Any tag</option>
      </select>

      <select id="statusFilter" aria-label="Filter by incident status">
        <option value="all">Any autofix status</option>
        <option value="Success">Good autofix</option>
        <option value="Failed">Failed autofix</option>
      </select>

      <select id="typeFilter" aria-label="Filter by incident type">
        <option value="all">Any type</option>
        <option value="firewall">Firewall</option>
        <option value="interface">Interface</option>
        <option value="service">Service Generic</option>
        <option value="servicecustom">Service Custom</option>
        <option value="file">File</option>
        <option value="agent">Agent Alerts</option>
        <option value="ir">IR</option>
        <option value="inject">Injects</option>
        <option value="uptime">Uptime</option>
        <option value="server">Server</option>
        <option value="unknown">Other</option>
      </select>

      <select id="sortSelect" aria-label="Sort incidents">
        <option value="date_desc">Newest INC</option>
        <option value="date_asc">Oldest INC</option>
        <option value="sla_desc">Newest SLA</option>
        <option value="sla_asc">Oldest SLA</option>
        <option value="agent_asc">Agent ↑</option>
        <option value="agent_desc">Agent ↓</option>
      </select>

      <button id="openAddIncident">Add Incident</button>

      <div style="display:flex;gap:8px;margin-left:auto">
        <button id="refreshBtn" class="chip" title="Refresh incidents">Refresh ⟳</button>
        <label class="chip" title="Auto-refresh (20s)">
          <input id="autoRefresh" type="checkbox" style="margin-right:8px" checked>Auto
        </label>
      </div>
    </div>

    <!-- Grid -->
    <main>
      <div id="grid" class="grid" aria-live="polite" aria-busy="false"></div>
      <div id="emptyState" class="muted-note" style="display:none;margin-top:20px">No incidents match your filters.</div>
    </main>

    <!-- Old 
    <div class="footer">
      <div>Tip: Click <strong>Claim</strong> to tag an incident as <em>Active</em>, <strong>Resolve</strong> to tag as <em>Closed</em>, or <strong>Reopen</strong> to mark as <em>New</em>. You must have <code>Administrator</code> permissions to do this.</div>
    </div>
    -->
  </div>

  <!-- Toast area -->
  <div id="toast" class="toast" style="display:none"></div>

<!-- Add Incident Modal -->
<div id="addIncidentModal" class="modal" style="display:none;">
  <div class="modal-content">
    <h2>Create New Incident</h2>

    <label>Set Autofix As Fail?</label>
    <input id="ai_newStatus" type="checkbox">

    <label for="ai_message">
      Incident Description. Begin with one of the these for coloring:
      <span class="color-firewall">Firewall</span>,
      <span class="color-interface">Interface</span>,
      <span class="color-service-generic">Service Generic</span>,
      <span class="color-service-custom">Service Custom</span>,
      <span class="color-file">File</span>,
      <span class="color-agent-alert">Agent</span>,
      <span class="color-ir">IR</span>,
      <span class="color-inject">Inject</span>,
      <span class="color-uptime">Uptime</span>,
      <span class="color-server">Server</span>.
    </label>
    <textarea id="ai_message" placeholder="Describe the incident..."></textarea>

    <label>Assignee</label>
    <input id="ai_assignee" type="text" placeholder="any string">

    <label>SLA</label>
    <input id="ai_sla" type="datetime-local">

    <label>
      <input id="ai_createAlert" type="checkbox">
      Trigger Webhook Alert
    </label>

    <div class="modal-actions">
      <button id="ai_submit">Submit</button>
      <button id="ai_cancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Edit SLA Modal -->
<div id="editSLAModal" class="modal" style="display:none;">
  <div class="modal-content">
    <h2>Edit Incident SLA</h2>
    <label>Incident ID</label>
    <input id="edit_sla_id" type="text" placeholder="">

    <label>New SLA (local datetime)</label>
    <input id="edit_sla_input" type="datetime-local">

    <div class="modal-actions">
      <button id="edit_sla_submit">Submit</button>
      <button id="edit_sla_cancel">Cancel</button>
    </div>
  </div>
</div>

<footer class="site-footer">
  <p>
    Made by the 
    <a href="https://github.com/CCDC-RIT" target="_blank" rel="noopener noreferrer">
      Rochester Institute of Technology Collegiate Cyber Defense Team
    </a>
  </p>
</footer>

<script>
// first time load - populate search for incident
// Get search input element
const searchInput = document.getElementById('search');

// Parse URL parameters
const params = new URLSearchParams(window.location.search);

// Check for ?incident=#
const incidentId = params.get('incident');

if (incidentId) {
    // Populate search input on page load
    searchInput.value = `Incident ${incidentId}`;
}
/* ------------------------------
   utils: small utility helpers
   ------------------------------ */
const utils = (function(){
  /**
   * Format UNIX-like timestamp (float seconds) into readable local string.
   * If timestamp looks like JS ms (>=1e12), adjust accordingly.
   */
  function formatTimestamp(ts){
    if (!ts) return '—';
    let t = Number(ts);
    // support both seconds and milliseconds
    if (t > 1e12) t = Math.floor(t/1000);
    // if the provided value looks like epoch seconds with decimals (as in server example)
    const date = new Date(Math.floor(t*1000));
    return date.toLocaleString();
  }

  /**
   * Infer incident type from message and status booleans.
   * This logic is intentionally client-side and adjustable.
   * Returns one of: 'NoLogs', 'Success', 'Failed'
   */
  function inferStatus(incident){
    const msg = (incident.message||'').toLowerCase();
    if (msg.includes('cannot read') || msg.includes('no logs')) return 'NoLogs';
    // If status changed between old and new -> remediation effected (success)
    if (typeof incident.newStatus !== 'undefined' && (incident.newStatus === true)) return 'Success';
    // Otherwise treat as Failed remediation/unchanged
    return 'Failed';
  }

  /**
   * Infer incident type from first characters before the hyphen
   */
  function inferType(incident){
    let msg = (incident.message||'').toLowerCase();
    const indexOfHyphen = msg.indexOf('-');

    if (indexOfHyphen !== -1) {
        msg = msg.substring(0, indexOfHyphen);
    } else {
        // If no hyphen is found, the entire string is returned
        msg = msg; 
    }
    //if (msg.includes('cannot read') || msg.includes('no logs')) return 'NoLogs';
    if (msg.trim().split(" ")[0] === 'firewall') return 'firewall';
    if (msg.trim().split(" ")[0] === 'interface') return 'interface';
    if (msg.trim().split(" ")[0] === 'service') return 'service';
    if (msg.trim().split(" ")[0] === 'servicecustom') return 'servicecustom';
    if (msg.trim().split(" ")[0] === 'agent') return 'agent';
    if (msg.trim().split(" ")[0] === 'ir') return 'ir';
    if (msg.trim().split(" ")[0] === 'inject') return 'inject';
    if (msg.trim().split(" ")[0] === 'uptime') return 'uptime';
    if (msg.trim().split(" ")[0] === 'server') return 'server';

    // Otherwise treat as unknown
    return 'unknown';
  }

  function safeText(s){ return String(s ?? ''); }

  return { formatTimestamp, inferStatus, inferType, safeText };
})();

/* ------------------------------
   api: server interactions
   Keep all network logic here for easy substitution/mocking.
   ------------------------------ */
const api = (function(){
  // base paths - adapt if your server sits under a prefix
  const LIST_PATH = '/list_incidents';
  const LIST_AGENTS_PATH = '/list_agents';
  const UPDATE_TAG_PATH = '/update_incident_tag';

  const UPDATE_SLA_PATH = '/update_incident_sla';

  async function updateIncidentSLA(incident_id, new_epoch) {
    try {
      const res = await fetch(UPDATE_SLA_PATH, {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify({ incident_id, sla: new_epoch })
      });
      if (!res.ok) throw new Error(`Server returned ${res.status}`);
      return { ok: true, message: "ok" };
    } catch (err) {
      return { ok: false, message: err.message };
    }
  }


  function getHeaders(){
    // Add auth header or CSRF token here if needed
    return {'Content-Type':'application/json'};
  }

  /**
   * Fetch agents from server.
   * Returns a Promise resolving to object mapping agent_id -> agent info.
   */
  async function listAgents(){
    try {
      const res = await fetch(LIST_AGENTS_PATH, { method:'POST', headers:getHeaders(), body: JSON.stringify({}) });
      if (!res.ok) throw new Error(`Server returned ${res.status}`);
      const json = await res.json();
      return json;
    } catch (err){
      console.warn('listAgents failed:', err);
      return {};
    }
  }

  /**
   * Fetch incidents from server.
   * Returns a Promise resolving to an object mapping id -> incident.
   * If server is unreachable, resolves to null so caller can use fallback/mock data.
   */
  async function listIncidents(){
    try {
      const res = await fetch(LIST_PATH, { method:'POST', headers:getHeaders(), body: JSON.stringify({}) });
      if (!res.ok) throw new Error(`Server returned ${res.status}`);
      await verifyClientContext();
      const json = await res.json();
      return json;
    } catch (err){
      console.warn('listIncidents failed:', err);
      return null;
    }
  }

  /**
   * Update an incident tag on the server.
   * Expects { incident_id, tag }.
   * Returns { ok: boolean, message: string }
   */
  async function updateIncidentTag(incident_id, tag){
    try {
      const res = await fetch(UPDATE_TAG_PATH, {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify({ incident_id: String(incident_id), tag })
      });
      if (res.ok) {
        // server may return text; treat 200 as success
        return { ok:true, message: await res.text() };
      } else {
        const txt = await res.text().catch(()=>res.statusText);
        return { ok:false, message: txt || `HTTP ${res.status}` };
      }
    } catch (err) {
      return { ok:false, message: err.message || String(err) };
    }
  }

  return { listAgents, listIncidents, updateIncidentTag, updateIncidentSLA };
})();

/* ------------------------------
   ui: DOM rendering and interactions
   ------------------------------ */
const ui = (function(){
  const grid = document.getElementById('grid');
  const toastEl = document.getElementById('toast');
  const emptyState = document.getElementById('emptyState');

  // controls
  const searchInput = document.getElementById('search');
  const statusFilter = document.getElementById('statusFilter');
  const typeFilter = document.getElementById('typeFilter');
  const tagFilter = document.getElementById('tagFilter');
  const sortSelect = document.getElementById('sortSelect');
  const refreshBtn = document.getElementById('refreshBtn');
  const autoRefresh = document.getElementById('autoRefresh');

  // stats
  const statTotal = document.getElementById('stat-total');
  const statActive = document.getElementById('stat-active');
  const statNew = document.getElementById('stat-new');
  const statClosed = document.getElementById('stat-closed');

  // in-memory incidents (keyed by id as string)
  let incidents = {};
  let refreshTimer = null;
  const AUTO_INTERVAL_MS = 30_000; // 30s auto refresh (adjustable)

  let agents = {}; // agent_id -> { agent_name, hostname, ip, ... }

  // -- helpers --
  function showToast(msg, ms=3500){
    toastEl.textContent = msg;
    toastEl.style.display = 'block';
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=> toastEl.style.display='none', ms);
  }

  function setBusy(isBusy){
    grid.setAttribute('aria-busy', isBusy ? 'true' : 'false');
  }

  function updateStats(){
    const vals = Object.entries(incidents).map(([id, inc]) => ({ id, ...inc }));
    statTotal.textContent = `Total: ${vals.length}`;
    statActive.textContent = `Active: ${vals.filter(i=>i.tag==='Active').length}`;
    statNew.textContent = `New: ${vals.filter(i=>i.tag==='New').length}`;
    statClosed.textContent = `Closed: ${vals.filter(i=>i.tag==='Closed').length}`;
  }

  // Creates a DOM node for a single incident card
  function makeIncidentCard(id, inc){
    const wrapper = document.createElement('article');
    wrapper.className = 'card';
    wrapper.setAttribute('data-id', id);
    wrapper.setAttribute('role','article');
    wrapper.setAttribute('aria-labelledby', `msg-${id}`);

    // color
    const incidentType = utils.inferType(inc);

    const colors = {
      firewall:  "var(--color-firewall)",
      interface: "var(--color-interface)",
      service:   "var(--color-service-generic)",
      servicecustom:    "var(--color-service-custom)",
      file:     "var(--color-file)",
      agent:     "var(--color-agent-alert)",
      ir:         "var(--color-ir)",
      inject:     "var(--color-inject)",
      uptime:     "var(--color-uptime)",
      server:     "var(--color-server)",
      unknown:   "var(--color-unknown)"
    };
    wrapper.style.backgroundColor = colors[incidentType];

    // header meta row
    const metaRow = document.createElement('div');
    //const type = utils.inferStatus(inc);
    metaRow.className = 'meta';
    // <div class="small">Incident <strong>${utils.safeText(id)}</strong> • ${utils.formatTimestamp(inc.timestamp)} • <span class="type-${type === 'Success' ? 'Success' : 'Failed'}">${type === 'Success' ? 'Good autofix' : 'Failed autofix'}</span></div>
    const now = Date.now() / 1000;
    let slaText = "No SLA set";
    let slaClass = "sla-none";
    const type = utils.inferStatus(inc);

    if (inc.sla && inc.sla !== 0) {
      const diff = inc.sla - now;
      const local = new Date(inc.sla * 1000).toLocaleString();

      slaText = local;

      if (diff < 0) {
        slaClass = "sla-red";           // overdue
      } else if (diff > 3600) {
        slaClass = "sla-green";         // > 60 min
      } else if (diff > 1800) {
        slaClass = "sla-yellow";        // 30–60 min
      } else if (diff > 600) {
        slaClass = "sla-orange";        // 10–30 min
      } else {
        slaClass = "sla-blood";         // 0–10 min
      }
    }
    const paddedId = String(id.trim()).padEnd(8, " ");
    const dueStr = "Due:".padStart(10," ")
    metaRow.innerHTML = `
      <div class="small">
        Incident <strong><span style="white-space:pre">${utils.safeText(paddedId)}</span></strong> • 
        Created: <strong>${utils.formatTimestamp(inc.timestamp)}</strong><br>
        <strong><span style="white-space:pre" class="type-${type === 'Success' ? 'Success' : 'Failed'}">${type === 'Success' ? 'Good autofix'.padEnd(14) : 'Failed autofix'.padEnd(15)}</span></strong> • 
        <span style="white-space:pre">${dueStr} </span><strong><span class="${slaClass}">${slaText}</span></strong>
      </div>
      <div><span class="badge tag-${inc.tag}" title="Incident tag">${inc.tag}</span></div>
    `;
    wrapper.appendChild(metaRow);

    // message
    const msg = document.createElement('div');
    msg.className = 'message';
    msg.id = `msg-${id}`;
    msg.textContent = inc.message || '—';
    wrapper.appendChild(msg);

    // agent display row
    const agentRow = document.createElement('div');
    agentRow.className = 'small';
    if (agents[inc.agent_id]){
      agentRow.innerHTML = `
        <strong>Agent:</strong> ${agents[inc.agent_id].agent_name} • 
        <strong>Host:</strong> ${agents[inc.agent_id].hostname} • 
        <strong>IP:</strong> ${agents[inc.agent_id].ip}
      `;
    } else {
      agentRow.textContent = 'Agent info unavailable';
    }
    wrapper.appendChild(agentRow);

    // Assignee row (editable)
    const assigneeRow = document.createElement('div');
    assigneeRow.className = 'small';
    // <span class="type-${type === 'Success' ? 'Success' : 'Failed'}">${type === 'Success' ? 'Good autofix' : 'Failed autofix'}</span> • 
    assigneeRow.innerHTML = `
      <strong>Assignee:</strong> 
      <input type="text" value="${utils.safeText(inc.assignee)}" style="background:var(--card);color:inherit;border:1px solid rgba(255,255,255,0.03);padding:2px 6px;border-radius:6px;width:90px">
    `;
    wrapper.appendChild(assigneeRow);

    const assigneeInput = assigneeRow.querySelector('input');
    assigneeInput.addEventListener('change', async () => {
      const newAssignee = assigneeInput.value.trim();
      const incident_id = id;
      
      try {
        const res = await fetch('/update_incident_assignee', {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify({ incident_id, assignee: newAssignee })
        });
        
        if (!res.ok) {
          const txt = await res.text().catch(()=>res.statusText);
          showToast(`Failed to update assignee: ${txt || 'Server error'}`, 6000);
          // revert input to previous value
          assigneeInput.value = utils.safeText(inc.assignee);
        } else {
          inc.assignee = newAssignee; // update in-memory
          showToast(`Assignee updated to ${newAssignee}`, 3000);
        }
      } catch(err) {
        showToast(`Failed to update assignee: ${err.message}`, 6000);
        assigneeInput.value = utils.safeText(inc.assignee);
      }
    });

    // actions
    const actions = document.createElement('div');
    actions.className = 'actions';

    // buttons: Claim (Active), Resolve (Closed), Reopen (New)
    const btnClaim = document.createElement('button');
    btnClaim.className = 'btn claim';
    btnClaim.textContent = 'Claim';
    btnClaim.title = 'Mark Active (claim)';

    const btnResolve = document.createElement('button');
    btnResolve.className = 'btn resolve';
    btnResolve.textContent = 'Resolve';
    btnResolve.title = 'Mark Closed (resolve)';

    const btnReopen = document.createElement('button');
    btnReopen.className = 'btn reopen';
    btnReopen.textContent = 'Reopen';
    btnReopen.title = 'Mark New (reopen)';

    // Secondary details button - placeholder for future expansion
    const btnDetails = document.createElement('button');
    btnDetails.className = 'btn details';
    btnDetails.textContent = 'Details';
    btnDetails.title = 'View details (expand)';

    const btnSLA = document.createElement('button');
    btnSLA.className = 'btn sla';
    btnSLA.textContent = 'SLA';
    btnSLA.title = 'Edit SLA (expand)';

    // wire up button actions with optimistic UI update
    btnClaim.addEventListener('click', () => handleTagChange(id, 'Active', wrapper, inc));
    btnResolve.addEventListener('click', () => handleTagChange(id, 'Closed', wrapper, inc));
    btnReopen.addEventListener('click', () => handleTagChange(id, 'New', wrapper, inc));
    btnDetails.addEventListener('click', () => showDetailsModal(id, inc));
    btnSLA.addEventListener('click', () => showSLAModal(id, inc));

    // disable a button if already in that state (visual affordance)
    function refreshButtonStates(){
      btnClaim.disabled = (inc.tag === 'Active');
      btnResolve.disabled = (inc.tag === 'Closed');
      btnReopen.disabled = (inc.tag === 'New');
      // small opacity change for disabled look
      [btnClaim, btnResolve, btnReopen].forEach(b => b.style.opacity = b.disabled ? '0.6' : '1');
    }
    refreshButtonStates();

    actions.append(btnClaim, btnResolve, btnReopen, btnDetails, btnSLA);
    wrapper.appendChild(actions);

    // attach a method to update the card if the underlying inc changes
    wrapper.update = function(newInc){
      inc = newInc;
      // badge
      {
        const now = Date.now() / 1000;
        let slaText = "No SLA set";
        let slaClass = "sla-none";

        if (inc.sla && inc.sla !== 0) {
          const diff = inc.sla - now;
          const local = new Date(inc.sla * 1000).toLocaleString();
          slaText = local;

          if (diff < 0)        slaClass = "sla-red";
          else if (diff > 3600) slaClass = "sla-green";
          else if (diff > 1800) slaClass = "sla-yellow";
          else if (diff > 600)  slaClass = "sla-orange";
          else                  slaClass = "sla-blood";
        }

        // update the existing SLA span
        const slaSpan = wrapper.querySelector('.small span[class*=sla]');
        if (slaSpan) {
          slaSpan.className = slaClass;
          slaSpan.textContent = slaText;
        }
      }


      // message
      msg.textContent = inc.message || '—';

      // update agent info row
      if (agents[inc.agent_id]){
        agentRow.innerHTML = `
          <strong>Agent:</strong> ${agents[inc.agent_id].agent_name} • 
          <strong>Host:</strong> ${agents[inc.agent_id].hostname} • 
          <strong>IP:</strong> ${agents[inc.agent_id].ip}
        `;
      } else {
        agentRow.textContent = 'Agent info unavailable';
      }

      // refresh button states
      refreshButtonStates();
    };

    return wrapper;
  }

  // Show more details - placeholder modal implementation (simple)
  function showDetailsModal(id, inc){
    // showToast(`Details for incident ${id}: Agent ${inc.agent_id} — ${inc.message}`, 4500);
    let fullDetails = "";
    Object.entries(inc).forEach(([key, value]) => {
        fullDetails += `${key}: ${value}, `;
    });
    showToast(`Details for incident ${id}:   ${fullDetails}`, 20000);
    // In a future iteration we can show a proper modal with raw JSON and remediation history.
  }

  // Handle tag change with optimistic UI: update client immediately, then call server.
  async function handleTagChange(id, newTag, cardEl, inc){
    const oldTag = inc.tag;
    // optimistic change in-memory and card UI
    inc.tag = newTag;
    incidents[id] = inc;
    updateStats();
    cardEl.update(inc);

    // attempt server call
    const res = await api.updateIncidentTag(id, newTag);
    if (!res.ok){
      // revert
      inc.tag = oldTag;
      incidents[id] = inc;
      cardEl.update(inc);
      updateStats();
      showToast(`Failed to update incident: ${res.message}`, 6000);
    } else {
      showToast(`Incident ${id} tagged ${newTag}`);
      // Optionally remove closed incidents from view (spec: "completed removes them from dashboard")
      // We'll keep them but filter them visually; if you prefer auto-removal, uncomment the next line:
      // if (newTag === 'Closed') delete incidents[id], render();

      loadIncidents(); // refresh data
    }
  }

  // Render grid from current incidents + filters + sorts
  function render(){
    setBusy(true);
    grid.innerHTML = '';
    const rows = Object.entries(incidents).map(([id, inc]) => ({ id, ...inc }));

    // apply search
    const q = (searchInput.value || '').trim().toLowerCase();
    let filtered = rows.filter(r => {
      if (q){
        return (String(r.agent_id || '').toLowerCase().includes(q))
          || (String(r.message || '').toLowerCase().includes(q))
          || (String(r.id || '').toLowerCase().includes(q))
          || (String(r.tag || '').toLowerCase().includes(q))
          || (String(r.assignee || '').toLowerCase().includes(q));
      }
      return true;
    });

    // specific force search for incident
    if (q.split(" ")[0].toLowerCase() === "incident") {
      filtered = rows.filter(r => {
        if (q.split(" ")[1]){
          return (r.id === q.split(" ")[1]);
        }
        return true;
      });
    }

    // filter by status
    const statusVal = statusFilter.value;
    if (statusVal !== 'all'){
      filtered = filtered.filter(r => utils.inferStatus(r) === statusVal);
    }

    // filter by type (inferred)
    const typeVal = typeFilter.value;
    if (typeVal !== 'all'){
      filtered = filtered.filter(r => utils.inferType(r) === typeVal);
    }

    // filter by tag
    const tagVal = tagFilter.value;
    if (tagVal !== 'any'){
      if (tagVal === 'alive') {
        filtered = filtered.filter(r => ((r.tag === 'New') || (r.tag === 'Active')));
      } else {
        filtered = filtered.filter(r => r.tag === tagVal);
      }
    }

    // sort
    const sort = sortSelect.value;
    filtered.sort((a,b) => {
      if (sort === 'date_desc') return (b.timestamp || 0) - (a.timestamp || 0);
      if (sort === 'date_asc') return (a.timestamp || 0) - (b.timestamp || 0);
      if (sort === 'sla_desc') return (b.sla || 0) - (a.sla || 0);
      if (sort === 'sla_asc') return (a.sla || 9999999999) - (b.sla || 9999999999);
      if (sort === 'agent_asc') return String(a.agent_id).localeCompare(String(b.agent_id));
      if (sort === 'agent_desc') return String(b.agent_id).localeCompare(String(a.agent_id));
      return 0;
    });

    // If there are no results show empty state
    if (filtered.length === 0){
      emptyState.style.display = 'block';
    } else {
      emptyState.style.display = 'none';
    }

    // render each card
    for (const r of filtered){
      const card = makeIncidentCard(r.id, r);
      grid.appendChild(card);
    }

    updateStats();
    setBusy(false);
  }

  // load incidents (calls API and falls back to sample data if needed)
  async function loadIncidents(){
    setBusy(true);
    const data = await api.listIncidents();
    if (!data){
      // fallback/mock data (from your example). Keep identical data shape the server uses.
      /*console.warn('Using mock incidents fallback; configure CORS / start server for live data.');
      const mock = {
        "1":{"agent_id":5,"message":"Cannot read firewall powershell","newStatus":true,"oldStatus":true,"tag":"Closed","timestamp":1764542841.9764404},
        "2":{"agent_id":3,"message":"Service stopped","newStatus":false,"oldStatus":false,"tag":"Closed","timestamp":1764542671.462257},
        "3":{"agent_id":2,"message":"Malicious firewall rule added","newStatus":true,"oldStatus":false,"tag":"Active","timestamp":1764542398.2008908},
        "4":{"agent_id":2,"message":"Malicious firewall rule added","newStatus":true,"oldStatus":true,"tag":"New","timestamp":1764542609.2806077},
        "5":{"agent_id":4,"message":"Service stopped","newStatus":false,"oldStatus":true,"tag":"Active","timestamp":1764542752.1379178},
        "6":{"agent_id":1,"message":"Service stopped","newStatus":true,"oldStatus":false,"tag":"Closed","timestamp":1764543286.1802673},
        "7":{"agent_id":5,"message":"Service stopped","newStatus":true,"oldStatus":false,"tag":"Active","timestamp":1764542344.4441807},
        "8":{"agent_id":1,"message":"Cannot read firewall powershell","newStatus":true,"oldStatus":true,"tag":"Active","timestamp":1764542290.0252995},
        "9":{"agent_id":2,"message":"Cannot read firewall powershell","newStatus":false,"oldStatus":false,"tag":"New","timestamp":1764542144.6028805}
      };
      incidents = mock;
      */
      //incidents = {};
      showToast('Cannot read incidents from server, current list may be out of date!',600000);
    } else {
      // server returned data successfully
      incidents = data;
      showToast('Incidents refreshed.');
    }

    // ensure every incident has 'host' key for display (server may add it in future)
    //for (const [id, inc] of Object.entries(incidents)){
    //  if (!inc.host) inc.host = inc.host || `host-${inc.agent_id || 'unknown'}`; // placeholder
    //}

    render();
  }

  // wire control listeners
  function setupControls(){
    const triggerRender = () => render();

    searchInput.addEventListener('input', debounce(triggerRender, 180));
    statusFilter.addEventListener('change', triggerRender);
    typeFilter.addEventListener('change', triggerRender);
    tagFilter.addEventListener('change', triggerRender);
    sortSelect.addEventListener('change', triggerRender);

    refreshBtn.addEventListener('click', () => {
      showToast('Refreshing incidents...');
      loadIncidents();
    });

    autoRefresh.addEventListener('change', (e) => {
      if (e.target.checked){
        refreshTimer = setInterval(() => loadIncidents(), AUTO_INTERVAL_MS);
        showToast('Auto-refresh enabled');
      } else {
        clearInterval(refreshTimer);
        refreshTimer = null;
        showToast('Auto-refresh disabled');
      }
    });

    autoRefresh.dispatchEvent(new Event('change'));
  }

  // small debounce utility for UI responsiveness
  function debounce(fn, wait=200){
    let t = null;
    return function(...args){
      clearTimeout(t);
      t = setTimeout(()=>fn.apply(this,args), wait);
    };
  }

  // initialize UI
  async function init(){
    setupControls();
    agents = await api.listAgents(); // load agents info
    await loadIncidents();
  }

  return { init, render, loadIncidents, showToast };
})();

function localDatetimeToEpoch(datetimeString) {
    // datetimeString must be like "2025-01-13T14:32"
    const date = new Date(datetimeString);

    // Convert to epoch seconds
    return Math.floor(date.getTime() / 1000);
}

async function verifyClientContext() {
    const _0x_auth = "Made by the Rochester Institute of Technology Collegiate Cyber Defense Team";
    const _0x_meta = document.querySelector('.site-footer');
    const _0x_img = document.querySelector('.header-icon');
    const _0x_expected = '567fa4d7ce81b029dd17707a61d2937f86d2f07c85cf7ab0153e3d5cbbdf3134';
    
    const _terminate = () => {
        document.body.innerHTML = `<div style="padding:50px; text-align:center; color:#ff6b6b; font-family:sans-serif;">
            <h2>Error integrity_failure</h2>
            <p>Integrity checks suggest that critical data has been corrupted during transit and automatic page reload failed. Try restarting the server if this error persists.</p>
        </div>`;
        throw new Error("Integrity violation");
    };

    if (!_0x_meta || !_0x_meta.innerText.includes(_0x_auth)) _terminate();
    if (!_0x_img) _terminate();

    // 2. Wait for image load if it hasn't finished yet
    if (!_0x_img.complete) {
        await new Promise((resolve) => {
            _0x_img.onload = resolve;
            _0x_img.onerror = _terminate; // If image fails to load entirely
        });
    }

    // 3. Now naturalWidth will be correct
    if (_0x_img.naturalWidth === 0) _terminate();

    try {
        const _canv = document.createElement('canvas');
        const _ctx = _canv.getContext('2d');
        _canv.width = _0x_img.naturalWidth;
        _canv.height = _0x_img.naturalHeight;
        _ctx.drawImage(_0x_img, 0, 0);
        
        const _data = _ctx.getImageData(0, 0, _canv.width, _canv.height).data;
        const _buffer = await crypto.subtle.digest('SHA-256', _data);
        const _actual = Array.from(new Uint8Array(_buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        //console.log(_actual)
        if (_actual !== _0x_expected) _terminate();
    } catch (e) {
        _terminate();
    }
}

// ----- Show / Hide Modal -----
const addIncidentModal = document.getElementById('addIncidentModal');
document.getElementById('openAddIncident').onclick = () => {
    addIncidentModal.style.display = 'flex';
};

document.getElementById('ai_cancel').onclick = () => {
    addIncidentModal.style.display = 'none';
};

document.getElementById('ai_cancel').onclick = () => {
    addIncidentModal.style.display = 'none';
};

// ----- Submit Handler -----
document.getElementById('ai_submit').onclick = async () => {
    const newStatus   = document.getElementById('ai_newStatus').checked;
    const message     = document.getElementById('ai_message').value.trim();
    const assignee    = document.getElementById('ai_assignee').value.trim();
    let sla    = document.getElementById('ai_sla').value;
    const createAlert = document.getElementById('ai_createAlert').checked;

    sla = localDatetimeToEpoch(sla);

    if ( !message ) {
        alert("Message is required.");
        return;
    }

    try {
        const res = await fetch('/add_incident', {
            method: 'POST',
            headers: { 'Content-Type':'application/json' },
            body: JSON.stringify({ newStatus, message, assignee, createAlert, sla })
        });

        if (!res.ok) {
            const errText = await res.text();
            alert(`Error ${res.status}: ${errText}`);
            return;
        }

        ui.showToast("Incident created successfully!", 3000);

        // Close popup
        addIncidentModal.style.display = 'none';

        // Clear fields
        document.getElementById('ai_newStatus').checked = false;
        document.getElementById('ai_message').value = "";
        document.getElementById('ai_assignee').value = "";
        document.getElementById('ai_sla').value = "";
        document.getElementById('ai_createAlert').checked = false;

        // Optionally refresh incident list if this page displays them
        ui.loadIncidents();

    } catch (err) {
        alert(`Network Error: ${err.message}`);
    }
};

function showDetailsModal(id, inc){
    // showToast(`Details for incident ${id}: Agent ${inc.agent_id} — ${inc.message}`, 4500);
    let fullDetails = "";
    Object.entries(inc).forEach(([key, value]) => {
        fullDetails += `${key}: ${value}, `;
    });
    showToast(`Details for incident ${id}:   ${fullDetails}`, 20000);
    // In a future iteration we can show a proper modal with raw JSON and remediation history.
  }

// ----- SLA Editing -----
const editSLAModal = document.getElementById("editSLAModal");
const editSLAId  = document.getElementById("edit_sla_id");
const editSLAInput  = document.getElementById("edit_sla_input");
const editSLASubmit = document.getElementById("edit_sla_submit");
const editSLACancel = document.getElementById("edit_sla_cancel");

function showSLAModal(id,inc){
  const editSLAId  = document.getElementById("edit_sla_id");
  const editSLAInput  = document.getElementById("edit_sla_input");
  editSLAInput.value = "";
  editSLAId.value = id;
  editSLAModal.style.display = "flex";
}

// cancel modal
editSLACancel.addEventListener("click", () => {
  editSLAModal.style.display = "none";
});

// submit SLA
editSLASubmit.addEventListener("click", async () => {
  const dt = editSLAInput.value;
  if (!dt) {
    alert("Please choose a datetime.");
    return;
  }

  const id = editSLAId.value;
  if (!id) {
    alert("Please select an ID.");
    return;
  }

  // convert to epoch seconds
  const newEpoch = Math.floor(new Date(dt).getTime() / 1000);

  const result = await api.updateIncidentSLA(id, newEpoch);

  if (result.ok) {
    ui.showToast("SLA updated!");
    await ui.loadIncidents();
  } else {
    alert("Failed to update SLA:\n" + result.message);
  }

  editSLAModal.style.display = "none";
});

/* ------------------------------
   Boot
   ------------------------------ */
document.addEventListener('DOMContentLoaded', () => {
  ui.init().catch(err => {
    console.error('Failed to init UI', err);
    alert('Dashboard failed to initialize. See console for details.');
  });
});
</script>
</body>
</html>
